/*
 * Copyright 2012 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.splunk;

/**
 * Contains arguments used to create a {@link Job}.
 */
public class JobArgs extends Args {
    
    /**
     * Affects how a call to {@link JobCollection#create} operates.
     */
    public static enum ExecutionMode {
        /** Runs an asynchronous search. */
        NORMAL("normal"),
        /** Returns the sid when the job is complete. */
        BLOCKING("blocking"),
        /** Returns results in the same call. */
        ONESHOT("oneshot");
        
        private String value;
        
        private ExecutionMode(String value) {
            this.value = value;
        }
        
        /**
         * @return The REST API value for this enumerated constant.
         */
        public String toString() {
            return this.value;
        }
    }
    
    /**
     * Affects how a call to {@link JobCollection#create} operates.
     */
    public static enum SearchMode {
        /**
         * Search runs over historical data.
         */
        NORMAL("normal"),
        /**
         * Search runs over live data. A realtime search may also be indicated by earliest_time and latest_time variables starting with 'rt' even if the search_mode is set to normal or is unset. For a real-time search, if both earliest_time and latest_time are both exactly 'rt', the search represents all appropriate live data received since the start of the search.
         * 
         * Additionally, if earliest_time and/or latest_time are 'rt' followed by a relative time specifiers then a sliding window is used where the time bounds of the window are determined by the relative time specifiers and are continuously updated based on the wall-clock time.
         */
        REALTIME("realtime");
        
        private String value;
        
        private SearchMode(String value) {
            this.value = value;
        }
        
        /**
         * @return The REST API value for this enumerated constant.
         */
        public String toString() {
            return this.value;
        }
    }

    /**
     * Class constructor.
     */
    public JobArgs() { super(); }
    
    /* BEGIN AUTOGENERATED CODE */
    
    /**
     * @param autoCancel
     *      If specified, the job automatically cancels after this many seconds of inactivity. (0 means never auto-cancel)
     */
    public void setAutoCancel(int autoCancel) {
        this.put("auto_cancel", autoCancel);
    }
    
    /**
     * @param autoFinalizeEventCount
     *      Auto-finalize the search after at least this many events have been processed.
     *      
     *      Specify 0 to indicate no limit.
     */
    public void setAutoFinalizeEventCount(int autoFinalizeEventCount) {
        this.put("auto_finalize_ec", autoFinalizeEventCount);
    }
    
    /**
     * @param autoPause
     *      If specified, the job automatically cancels after this many seconds of inactivity. (0 means never auto-pause) 
     */
    public void setAutoPause(int autoPause) {
        this.put("auto_pause", autoPause);
    }
    
    /**
     * @param earliestTime
     *      Specify a time string. Sets the earliest (inclusive), respectively, time bounds for the search.
     *      
     *      The time string can be either a UTC time (with fractional seconds), a relative time specifier (to now) or a formatted time string. (Also see comment for the search_mode variable.)
     */
    public void setEarliestTime(String earliestTime) {
        this.put("earliest_time", earliestTime);
    }
    
    /**
     * @param enableLookups
     *      Indicates whether lookups should be applied to events.
     *      
     *      Specifying true (the default) may slow searches significantly depending on the nature of the lookups.
     */
    public void setEnableLookups(boolean enableLookups) {
        this.put("enable_lookups", enableLookups);
    }
    
    /**
     * @param executionMode
     *      If set to normal, runs an asynchronous search.
     *      
     *      If set to blocking, returns the sid when the job is complete.
     *      
     *      If set to oneshot, returns results in the same call. 
     */
    public void setExecutionMode(ExecutionMode executionMode) {
        this.put("exec_mode", executionMode);
    }
    
    /**
     * @param forceBundleReplication
     *      Specifies whether this search should cause (and wait depending on the value of sync_bundle_replication) for bundle synchronization with all search peers.
     */
    public void setForceBundleReplication(boolean forceBundleReplication) {
        this.put("force_bundle_replication", forceBundleReplication);
    }
    
    /**
     * @param id
     *      Optional string to specify the search ID (&lt:sid>). If unspecified, a random ID is generated.
     */
    public void setId(String id) {
        this.put("id", id);
    }
    
    /**
     * @param latestTime
     *      Specify a time string. Sets the latest (exclusive), respectively, time bounds for the search.
     *      
     *      The time string can be either a UTC time (with fractional seconds), a relative time specifier (to now) or a formatted time string. (Also see comment for the search_mode variable.)
     */
    public void setLatestTime(String latestTime) {
        this.put("latest_time", latestTime);
    }
    
    /**
     * @param maximumCount
     *      The number of events that can be accessible in any given status bucket.
     *      
     *      Also, in transforming mode, the maximum number of results to store. Specifically, in all calls, codeoffset+count <= max_count.
     */
    public void setMaximumCount(int maximumCount) {
        this.put("max_count", maximumCount);
    }
    
    /**
     * @param maximumTime
     *      The number of seconds to run this search before finalizing. Specify 0 to never finalize.
     */
    public void setMaximumTime(int maximumTime) {
        this.put("max_time", maximumTime);
    }
    
    /**
     * @param namespace
     *      The application namespace in which to restrict searches.
     *      
     *      The namespace corresponds to the identifier recognized in the /services/apps/local endpoint.
     */
    public void setNamespace(String namespace) {
        this.put("namespace", namespace);
    }
    
    /**
     * @param now
     *      Specify a time string to set the absolute time used for any relative time specifier in the search. Defaults to the current system time.
     *      
     *      You can specify a relative time modifier for this parameter. For example, specify +2d to specify the current time plus two days.
     *      
     *      If you specify a relative time modifier both in this parameter and in the search string, the search string modifier takes precedence.
     *      
     *      Refer to <a href="http://docs.splunk.com/Documentation/Splunk/4.3.4/SearchReference/SearchTimeModifiers">Time modifiers for search</a> for details on specifying relative time modifiers. 
     */
    public void setNow(String now) {
        this.put("now", now);
    }
    
    /**
     * @param reduceFrequency
     *      Determines how frequently to run the MapReduce reduce phase on accumulated map values. 
     */
    public void setReduceFrequency(int reduceFrequency) {
        this.put("reduce_freq", reduceFrequency);
    }
    
    /**
     * @param reloadMacros
     *      Specifies whether to reload macro definitions from macros.conf.
     *      
     *      Default is true.
     */
    public void setReloadMacros(boolean reloadMacros) {
        this.put("reload_macros", reloadMacros);
    }
    
    /**
     * @param remoteServerList
     *      List of (possibly wildcarded) servers from which raw events should be pulled. This same server list is to be used in subsearches.
     */
    public void setRemoteServerList(String[] remoteServerList) {
        StringBuilder csv = new StringBuilder();
        for (int i = 0, n = remoteServerList.length; i < n; i++) {
            if (i != 0) {
                csv.append(",");
            }
            csv.append(remoteServerList[i]);
        }
        
        this.put("remote_server_list", String.valueOf(csv));
    }
    
    /**
     * @param requiredFieldList
     *      Required fields for the search.
     *      
     *      These fields, even if not referenced or used directly by the search, are still included by the events and summary endpoints. Splunk Web uses these fields to prepopulate panels in the Search view.
     */
    public void setRequiredFieldList(String[] requiredFieldList) {
        this.put("rf", requiredFieldList);
    }
    
    /**
     * @param realtimeBlocking
     *      For a realtime search, indicates if the indexer blocks if the queue for this search is full.
     */
    public void setRealtimeBlocking(boolean realtimeBlocking) {
        this.put("rt_blocking", realtimeBlocking);
    }
    
    /**
     * @param realtimeIndexFilter
     *      For a realtime search, indicates if the indexer prefilters events.
     */
    public void setRealtimeIndexFilter(boolean realtimeIndexFilter) {
        this.put("rt_indexfilter", realtimeIndexFilter);
    }
    
    /**
     * @param realtimeMaximumBlockSeconds
     *      For a realtime search with rt_blocking set to true, the maximum time to block.
     *      
     *      Specify 0 to indicate no limit.
     */
    public void setRealtimeMaximumBlockSeconds(int realtimeMaximumBlockSeconds) {
        this.put("rt_maxblocksecs", realtimeMaximumBlockSeconds);
    }
    
    /**
     * @param realtimeQueueSize
     *      For a realtime search, the queue size (in events) that the indexer should use for this search.
     */
    public void setRealtimeQueueSize(int realtimeQueueSize) {
        this.put("rt_queue_size", realtimeQueueSize);
    }
    
    /**
     * @param searchListener
     *      Registers a search state listener with the search.
     *      
     *      Use the format:
     *      
     *      search_state;results_condition;http_method;uri;
     *      
     *      For example:
     *      
     *      search_listener=onResults;true;POST;/servicesNS/admin/search/saved/search/foobar/notify;
     */
    public void setSearchListener(String searchListener) {
        this.put("search_listener", searchListener);
    }
    
    /**
     * @param searchMode
     *      If set to realtime, search runs over live data. A realtime search may also be indicated by earliest_time and latest_time variables starting with 'rt' even if the search_mode is set to normal or is unset. For a real-time search, if both earliest_time and latest_time are both exactly 'rt', the search represents all appropriate live data received since the start of the search.
     *      
     *      Additionally, if earliest_time and/or latest_time are 'rt' followed by a relative time specifiers then a sliding window is used where the time bounds of the window are determined by the relative time specifiers and are continuously updated based on the wall-clock time.
     */
    public void setSearchMode(SearchMode searchMode) {
        this.put("search_mode", searchMode);
    }
    
    /**
     * @param spawnProcess
     *      Specifies whether the search should run in a separate spawned process. Default is true.
     *      
     *      Searches against indexes must run in a separate process.
     */
    public void setSpawnProcess(boolean spawnProcess) {
        this.put("spawn_process", spawnProcess);
    }
    
    /**
     * @param statusBuckets
     *      The most status buckets to generate.
     *      
     *      0 indicates to not generate timeline information.
     */
    public void setStatusBuckets(int statusBuckets) {
        this.put("status_buckets", statusBuckets);
    }
    
    /**
     * @param synchronizeBundleReplication
     *      Specifies whether this search should wait for bundle replication to complete.
     */
    public void setSynchronizeBundleReplication(boolean synchronizeBundleReplication) {
        this.put("sync_bundle_replication", synchronizeBundleReplication);
    }
    
    /**
     * @param timeFormat
     *      Used to convert a formatted time string from {start,end}_time into UTC seconds. It defaults to ISO-8601.
     */
    public void setTimeFormat(String timeFormat) {
        this.put("time_format", timeFormat);
    }
    
    /**
     * @param timeout
     *      The number of seconds to keep this search after processing has stopped.
     */
    public void setTimeout(int timeout) {
        this.put("timeout", timeout);
    }
    
    /* END AUTOGENERATED CODE */
}
