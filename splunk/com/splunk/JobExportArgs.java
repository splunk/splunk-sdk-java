/*
 * Copyright 2012 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.splunk;

/**
 * Arguments for the {@link Service#export} method.
 */
public class JobExportArgs extends Args {
    
    /**
     * Specifies the format for the returned output. For details on each format, see Splunk responses to REST operations.
     */
    public static enum OutputMode {
        ALL("all"),
        ATOM("atom"),
        CSV("csv"),
        FULL("full"),
        JSON("json"),
        JSON_COLS("json_cols"),
        JSON_ROWS("json_rows"),
        SUMMARY("summary"),
        RAW("raw"),
        XML("xml");
        
        private String value;
        
        private OutputMode(String value) {
            this.value = value;
        }
        
        /**
         * @return The REST API value for this enumerated constant.
         */
        public String toString() {
            return this.value;
        }
    }
    
    /**
     * Affects how a call to {@link JobCollection#create} operates.
     */
    public static enum SearchMode {
        /**
         * Search runs over historical data.
         */
        NORMAL("normal"),
        /**
         * Search runs over live data. A realtime search may also be indicated by earliest_time and latest_time variables starting with 'rt' even if the search_mode is set to normal or is unset. For a real-time search, if both earliest_time and latest_time are both exactly 'rt', the search represents all appropriate live data received since the start of the search.
         * 
         * Additionally, if earliest_time and/or latest_time are 'rt' followed by a relative time specifiers then a sliding window is used where the time bounds of the window are determined by the relative time specifiers and are continuously updated based on the wall-clock time.
         */
        REALTIME("realtime");
        
        private String value;
        
        private SearchMode(String value) {
            this.value = value;
        }
        
        /**
         * @return The REST API value for this enumerated constant.
         */
        public String toString() {
            return this.value;
        }
    }
    
    /**
     * Specifies how "max_lines" should be achieved.
     */
    public static enum TruncationMode {
        ABSTRACT("abstract"),
        TRUNCATE("truncate");
        
        private String value;
        
        private TruncationMode(String value) {
            this.value = value;
        }
        
        /**
         * @return The REST API value for this enumerated constant.
         */
        public String toString() {
            return this.value;
        }
    }
    
    /**
     * Class constructor.
     */
    public JobExportArgs() { super(); }
    
    /* BEGIN AUTOGENERATED CODE */
    
    /**
     * @param indexEarliest
     *      Specify a time string. Sets the earliest (inclusive), respectively, time bounds for the search, based on the index time.
     *      
     *      The time string can be either a UTC time (with fractional seconds), a relative time specifier (to now) or a formatted time string.
     */
    public void setIndexEarliest(String indexEarliest) {
        this.put("index_earliest", indexEarliest);
    }
    
    /**
     * @param indexLatest
     *      Specify a time string. Sets the latest (inclusive), respectively, time bounds for the search, based on the index time.
     *      
     *      The time string can be either a UTC time (with fractional seconds), a relative time specifier (to now) or a formatted time string.
     */
    public void setIndexLatest(String indexLatest) {
        this.put("index_latest", indexLatest);
    }
    
    /**
     * @param outputMode
     *      Specifies the format for the returned output. For details on each format, see Splunk responses to REST operations.
     */
    public void setOutputMode(OutputMode outputMode) {
        this.put("output_mode", outputMode);
    }
    
    /**
     * @param autoCancel
     *      If specified, the job automatically cancels after this many seconds of inactivity. (0 means never auto-cancel)
     */
    public void setAutoCancel(int autoCancel) {
        this.put("auto_cancel", autoCancel);
    }
    
    /**
     * @param autoFinalizeEventCount
     *      Auto-finalize the search after at least this many events have been processed.
     *      
     *      Specify 0 to indicate no limit.
     */
    public void setAutoFinalizeEventCount(int autoFinalizeEventCount) {
        this.put("auto_finalize_ec", autoFinalizeEventCount);
    }
    
    /**
     * @param autoPause
     *      If specified, the job automatically cancels after this many seconds of inactivity. (0 means never auto-pause) 
     */
    public void setAutoPause(int autoPause) {
        this.put("auto_pause", autoPause);
    }
    
    /**
     * @param earliestTime
     *      Specify a time string. Sets the earliest (inclusive), respectively, time bounds for the search.
     *      
     *      The time string can be either a UTC time (with fractional seconds), a relative time specifier (to now) or a formatted time string. (Also see comment for the search_mode variable.)
     */
    public void setEarliestTime(String earliestTime) {
        this.put("earliest_time", earliestTime);
    }
    
    /**
     * @param enableLookups
     *      Indicates whether lookups should be applied to events.
     *      
     *      Specifying true (the default) may slow searches significantly depending on the nature of the lookups.
     */
    public void setEnableLookups(boolean enableLookups) {
        this.put("enable_lookups", enableLookups);
    }
    
    /**
     * @param forceBundleReplication
     *      Specifies whether this search should cause (and wait depending on the value of sync_bundle_replication) for bundle synchronization with all search peers.
     */
    public void setForceBundleReplication(boolean forceBundleReplication) {
        this.put("force_bundle_replication", forceBundleReplication);
    }
    
    /**
     * @param id
     *      Optional string to specify the search ID (&lt:sid>). If unspecified, a random ID is generated.
     */
    public void setId(String id) {
        this.put("id", id);
    }
    
    /**
     * @param latestTime
     *      Specify a time string. Sets the latest (exclusive), respectively, time bounds for the search.
     *      
     *      The time string can be either a UTC time (with fractional seconds), a relative time specifier (to now) or a formatted time string. (Also see comment for the search_mode variable.)
     */
    public void setLatestTime(String latestTime) {
        this.put("latest_time", latestTime);
    }
    
    /**
     * @param maximumTime
     *      The number of seconds to run this search before finalizing. Specify 0 to never finalize.
     */
    public void setMaximumTime(int maximumTime) {
        this.put("max_time", maximumTime);
    }
    
    /**
     * @param namespace
     *      The application namespace in which to restrict searches.
     *      
     *      The namespace corresponds to the identifier recognized in the /services/apps/local endpoint.
     */
    public void setNamespace(String namespace) {
        this.put("namespace", namespace);
    }
    
    /**
     * @param now
     *      Specify a time string to set the absolute time used for any relative time specifier in the search. Defaults to the current system time.
     *      
     *      You can specify a relative time modifier for this parameter. For example, specify +2d to specify the current time plus two days.
     *      
     *      If you specify a relative time modifier both in this parameter and in the search string, the search string modifier takes precedence.
     *      
     *      Refer to <a href="http://docs.splunk.com/Documentation/Splunk/4.3.4/SearchReference/SearchTimeModifiers">Time modifiers for search</a> for details on specifying relative time modifiers. 
     */
    public void setNow(String now) {
        this.put("now", now);
    }
    
    /**
     * @param reduceFrequency
     *      Determines how frequently to run the MapReduce reduce phase on accumulated map values. 
     */
    public void setReduceFrequency(int reduceFrequency) {
        this.put("reduce_freq", reduceFrequency);
    }
    
    /**
     * @param reloadMacros
     *      Specifies whether to reload macro definitions from macros.conf.
     *      
     *      Default is true.
     */
    public void setReloadMacros(boolean reloadMacros) {
        this.put("reload_macros", reloadMacros);
    }
    
    /**
     * @param remoteServerList
     *      List of (possibly wildcarded) servers from which raw events should be pulled. This same server list is to be used in subsearches.
     */
    public void setRemoteServerList(String[] remoteServerList) {
        StringBuilder csv = new StringBuilder();
            for (int i = 0, n = remoteServerList.length; i < n; i++) {
                if (i != 0) {
                    csv.append(",");
                }
                csv.append(remoteServerList[i]);
            }
            
            this.put("remote_server_list", String.valueOf(csv));
    }
    
    /**
     * @param requiredFieldList
     *      Required fields for the search.
     *      
     *      These fields, even if not referenced or used directly by the search, are still included by the events and summary endpoints. Splunk Web uses these fields to prepopulate panels in the Search view.
     */
    public void setRequiredFieldList(String[] requiredFieldList) {
        this.put("rf", requiredFieldList);
    }
    
    /**
     * @param realtimeBlocking
     *      For a realtime search, indicates if the indexer blocks if the queue for this search is full.
     */
    public void setRealtimeBlocking(boolean realtimeBlocking) {
        this.put("rt_blocking", realtimeBlocking);
    }
    
    /**
     * @param realtimeIndexFilter
     *      For a realtime search, indicates if the indexer prefilters events.
     */
    public void setRealtimeIndexFilter(boolean realtimeIndexFilter) {
        this.put("rt_indexfilter", realtimeIndexFilter);
    }
    
    /**
     * @param realtimeMaximumBlockSeconds
     *      For a realtime search with rt_blocking set to true, the maximum time to block.
     *      
     *      Specify 0 to indicate no limit.
     */
    public void setRealtimeMaximumBlockSeconds(int realtimeMaximumBlockSeconds) {
        this.put("rt_maxblocksecs", realtimeMaximumBlockSeconds);
    }
    
    /**
     * @param realtimeQueueSize
     *      For a realtime search, the queue size (in events) that the indexer should use for this search.
     */
    public void setRealtimeQueueSize(int realtimeQueueSize) {
        this.put("rt_queue_size", realtimeQueueSize);
    }
    
    /**
     * @param searchListener
     *      Registers a search state listener with the search.
     *      
     *      Use the format:
     *      
     *      search_state;results_condition;http_method;uri;
     *      
     *      For example:
     *      
     *      search_listener=onResults;true;POST;/servicesNS/admin/search/saved/search/foobar/notify;
     */
    public void setSearchListener(String searchListener) {
        this.put("search_listener", searchListener);
    }
    
    /**
     * @param searchMode
     *      If set to realtime, search runs over live data. A realtime search may also be indicated by earliest_time and latest_time variables starting with 'rt' even if the search_mode is set to normal or is unset. For a real-time search, if both earliest_time and latest_time are both exactly 'rt', the search represents all appropriate live data received since the start of the search.
     *      
     *      Additionally, if earliest_time and/or latest_time are 'rt' followed by a relative time specifiers then a sliding window is used where the time bounds of the window are determined by the relative time specifiers and are continuously updated based on the wall-clock time.
     */
    public void setSearchMode(SearchMode searchMode) {
        this.put("search_mode", searchMode);
    }
    
    /**
     * @param synchronizeBundleReplication
     *      Specifies whether this search should wait for bundle replication to complete.
     */
    public void setSynchronizeBundleReplication(boolean synchronizeBundleReplication) {
        this.put("sync_bundle_replication", synchronizeBundleReplication);
    }
    
    /**
     * @param timeFormat
     *      Used to convert a formatted time string from {start,end}_time into UTC seconds. It defaults to ISO-8601.
     */
    public void setTimeFormat(String timeFormat) {
        this.put("time_format", timeFormat);
    }
    
    /**
     * @param timeout
     *      The number of seconds to keep this search after processing has stopped.
     */
    public void setTimeout(int timeout) {
        this.put("timeout", timeout);
    }
    
    /**
     * @param count
     *      The maximum number of results to return. If value is set to 0, then all available results are returned. Default value is 100.
     */
    public void setCount(int count) {
        this.put("count", count);
    }
    
    /**
     * @param fieldList
     *      A list of fields to return for the event set.
     */
    public void setFieldList(String[] fieldList) {
        this.put("f", fieldList);
    }
    
    /**
     * @param maximumLines
     *      The maximum lines that any single event's _raw field should contain.
     *      
     *      Specify 0 to specify no limit.
     */
    public void setMaximumLines(int maximumLines) {
        this.put("max_lines", maximumLines);
    }
    
    /**
     * @param offset
     *      The first result (inclusive) from which to begin returning data.
     *      
     *      This value is 0-indexed. Default value is 0.
     *      
     *      In 4.1+, negative offsets are allowed and are added to count to compute the absolute offset (for example, offset=-1 is the last available offset. Offsets in the results are always absolute and never negative.
     */
    public void setOffset(int offset) {
        this.put("offset", offset);
    }
    
    /**
     * @param outputTimeFormat
     *      Formats a UTC time. Defaults to what is specified in time_format.
     */
    public void setOutputTimeFormat(String outputTimeFormat) {
        this.put("output_time_format", outputTimeFormat);
    }
    
    /**
     * @param search
     *      The post processing search to apply to results. Can be any valid search language string.
     */
    public void setSearch(String search) {
        this.put("search", search);
    }
    
    /**
     * @param segmentation
     *      The type of segmentation to perform on the data. This incudes an option to perform k/v segmentation.
     */
    public void setSegmentation(String segmentation) {
        this.put("segmentation", segmentation);
    }
    
    /**
     * @param truncationMode
     *      Specifies how "max_lines" should be achieved.
     *      
     *      Default value is abstract.
     */
    public void setTruncationMode(TruncationMode truncationMode) {
        this.put("truncation_mode", truncationMode);
    }
    
    /* END AUTOGENERATED CODE */
}
